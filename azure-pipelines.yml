trigger:
- main  # Cambia si tu rama principal es otra

# =========================
# Stage 1: Build (CI)
# =========================
stages:
- stage: Build
  displayName: "Build and Test"
  jobs:
  - job: BuildJob
    pool:
      name: Default  # Usa tu agente de Azure DevOps (puede ser Microsoft-hosted)
    variables:
      buildConfiguration: 'Release'
      ASPNETCORE_ENVIRONMENT: 'Development'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '9.0.x'  # Reemplaza por la versión exacta de .NET 9 que uses
        installationPath: $(Agent.ToolsDirectory)/dotnet

    - script: |
        cd SalesDatePrediction-back
        dotnet restore
      displayName: 'Restore dependencies'

    - script: |
        cd SalesDatePrediction-back
        dotnet build --configuration $(buildConfiguration) --no-restore
      displayName: 'Build project'

    - script: |
        cd SalesDatePrediction-back
        dotnet test SalesDatePrediction.Test/SalesDatePrediction.Test.csproj --verbosity normal
      displayName: 'Run tests'

    # Publicar artefactos para el deploy
    - script: |
        cd SalesDatePrediction-back
        dotnet publish --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)
      displayName: 'Publish artifacts'

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: drop

# =========================
# Stage 2: Deploy (CD)
# =========================
- stage: Deploy
  displayName: "Deploy to IIS"
  dependsOn: Build
  condition: succeeded()  # Solo se ejecuta si el build fue exitoso
  jobs:
  - deployment: DeployToIIS
    displayName: "Deploy on IIS Server"
    environment: 'IIS-Prod'  # Puedes dejarlo así o darle un nombre a tu entorno
    pool:
      name: Default  # Aquí debe estar el agente self-hosted en el servidor IIS
    strategy:
      runOnce:
        deploy:
          steps:
          - powershell: |
              $appPoolName = "SalesDatePredictionAPI"
              Import-Module WebAdministration
              $status = (Get-WebAppPoolState -Name $appPoolName).Value

              Write-Host "Estado actual del App Pool: $status"

              if ($status -eq "Started") {
                  Write-Host "Deteniendo App Pool..."
                  Stop-WebAppPool -Name $appPoolName
              } else {
                  Write-Host "El App Pool ya estaba detenido, continuando..."
              }
            displayName: "Stop IIS App Pool (si está iniciado)"

          - powershell: |
              $backupRoot = "C:\inetpub\wwwroot\backups\SalesDatePredictionAPI"
              $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
              $backupFile = "$backupRoot\SalesDatePredictionAPI_$timestamp.zip"

              # Crear carpeta de backups si no existe
              if (-not (Test-Path $backupRoot)) {
                  New-Item -ItemType Directory -Path $backupRoot | Out-Null
                  Write-Host "Carpeta de backups creada: $backupRoot"
              }

              # Comprimir el contenido actual del proyecto
              Compress-Archive -Path "C:\inetpub\wwwroot\SalesDatePredictionAPI\*" -DestinationPath $backupFile -Force

              Write-Host "Backup creado en: $backupFile"
            displayName: "Backup IIS Site"

          - task: CopyFiles@2
            displayName: "Copy files to IIS"
            inputs:
              SourceFolder: '$(Pipeline.Workspace)/drop'
              TargetFolder: 'C:\inetpub\wwwroot\SalesDatePredictionAPI'  # Cambia por la ruta de tu sitio
              OverWrite: true
              CleanTargetFolder: false
              Contents: |
                **/*
                !web.config

          - powershell: Start-WebAppPool -Name "SalesDatePredictionAPI"
            displayName: "Start IIS App Pool"
